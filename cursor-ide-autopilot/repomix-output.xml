This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

<additional_info>

</additional_info>

</file_summary>

<directory_structure>
actions/
  openai_vision.py
  screenshot.py
  send_to_cursor.py
  slack_webhook.py
docs/
  AUTOMATION.md
  CONFIGURATION.md
  INSTALLATION.md
  SETUP.md
  SLACK_BOT.md
utils/
  colored_logging.py
.dockerignore
.gitignore
.python-version
config.json
docker-compose.yml
Dockerfile
ensure_chat_window.py
generate_initial_prompt.py
README.md
requirements.txt
run_both.py
run.sh
slack_bot.py
state.py
watcher.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="utils/colored_logging.py">
import logging
import os

# ANSI color codes
COLORS = {
    'ensure_chat_window': '\033[36m',  # Cyan
    'kill_cursor': '\033[31m',         # Red
    'launch_platform': '\033[32m',     # Green
    'send_to_cursor': '\033[33m',      # Yellow
    'watcher': '\033[35m',             # Magenta
    'notice': '\033[34m',              # Blue
    'warning': '\033[93m',             # Light Yellow
    'error': '\033[91m',               # Light Red
    'debug': '\033[90m',               # Gray
    'info': '\033[37m',                # White
    'reset': '\033[0m'                 # Reset
}

class ColoredFormatter(logging.Formatter):
    def format(self, record):
        # Get the base logger name (first part before any dots)
        base_logger = record.name.split('.')[0]
        
        # Check if message contains a bracketed prefix
        message = record.msg
        if isinstance(message, str) and message.startswith('[') and ']' in message:
            prefix = message[1:message.index(']')]
            if prefix in COLORS:
                # Apply color to the bracketed prefix
                record.msg = f"{COLORS[prefix]}[{prefix}]{COLORS['reset']}{message[message.index(']')+1:]}"
            else:
                # Apply color based on logger name
                color = COLORS.get(base_logger, COLORS['info'])
                record.msg = f"{color}{message}{COLORS['reset']}"
        else:
            # Apply color based on logger name
            color = COLORS.get(base_logger, COLORS['info'])
            record.msg = f"{color}{message}{COLORS['reset']}"
        
        return super().format(record)

def setup_colored_logging(debug=False):
    # Create a handler that outputs to stdout
    handler = logging.StreamHandler()
    
    # Create formatter with timestamp and level
    formatter = ColoredFormatter(
        '%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Set the formatter
    handler.setFormatter(formatter)
    
    # Get the root logger
    root_logger = logging.getLogger()
    
    # Remove any existing handlers
    root_logger.handlers = []
    
    # Add our handler
    root_logger.addHandler(handler)
    
    # Set the logging level
    root_logger.setLevel(logging.DEBUG if debug else logging.INFO)
    
    # Return the root logger
    return root_logger
</file>

<file path="actions/slack_webhook.py">
# Placeholder if we separate Slack webhooks later
</file>

<file path=".dockerignore">
.git
.gitignore
venv
__pycache__
*.pyc
*.pyo
*.pyd
.Python
.env
*.log
</file>

<file path=".python-version">
3.13.2
</file>

<file path="docker-compose.yml">
version: '3.8'

services:
  cursor-autopilot:
    build: .
    volumes:
      - .:/app
      - /tmp/.X11-unix:/tmp/.X11-unix  # For X11 forwarding
    environment:
      - DISPLAY=${DISPLAY}
      - WATCH_PATH=${WATCH_PATH:-/app}
    network_mode: host  # Required for Slack webhook to work
    restart: unless-stopped
</file>

<file path="Dockerfile">
FROM python:3.13.2-slim

WORKDIR /app

# Install system dependencies
RUN apt-get update && apt-get install -y \
    tesseract-ocr \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements first to leverage Docker cache
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy the rest of the application
COPY . .

# Set environment variables
ENV PYTHONUNBUFFERED=1

# Command to run the application
CMD ["python", "run_both.py"]
</file>

<file path="requirements.txt">
flask  
openai 
pytesseract
</file>

<file path="actions/openai_vision.py">
import os
import openai
import logging
from utils.colored_logging import setup_colored_logging

# Configure logging
setup_colored_logging(debug=os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true")
logger = logging.getLogger('openai_vision')

def is_chat_window_open(screenshot_path):
    """
    Uses OpenAI Vision API to check if the chat window is open in the screenshot.
    Returns True if chat window is open, False if closed.
    """
    if not os.environ.get("OPENAI_API_KEY"):
        logger.warning("OPENAI_API_KEY not found in environment. Skipping vision check.")
        logger.info("Note: The chat window should be closed when Cursor initially opens.")
        logger.info("Will wait for the configured delay before proceeding.")
        return False
    
    try:
        client = openai.OpenAI(api_key=os.environ["OPENAI_API_KEY"])
        
        with open(screenshot_path, "rb") as image_file:
            response = client.chat.completions.create(
                model="gpt-4-vision-preview",
                messages=[
                    {
                        "role": "user",
                        "content": [
                            {
                                "type": "text",
                                "text": "Is the chat window open in this screenshot? Answer with just 'yes' or 'no'."
                            },
                            {
                                "type": "image_url",
                                "image_url": {
                                    "url": f"data:image/png;base64,{image_file.read().hex()}"
                                }
                            }
                        ]
                    }
                ],
                max_tokens=10
            )
            
            answer = response.choices[0].message.content.lower().strip()
            logger.debug(f"Vision API response: {answer}")
            return answer == "yes"
            
    except Exception as e:
        logger.error(f"Error checking chat window: {e}")
        logger.info("Note: The chat window should be closed when Cursor initially opens.")
        logger.info("Will wait for the configured delay before proceeding.")
        return False
</file>

<file path="actions/screenshot.py">
import os
import subprocess
import logging
from utils.colored_logging import setup_colored_logging

# Configure logging
setup_colored_logging(debug=os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true")
logger = logging.getLogger('screenshot')

def take_screenshot(filename="screenshot.png", platform="cursor"):
    """
    Takes a screenshot of the Cursor/Windsurf window and saves it as filename.
    Returns the path to the screenshot, or None if failed.
    """
    screenshot_dir = os.path.dirname(filename)
    if not os.path.exists(screenshot_dir):
        logger.info(f"Ensuring screenshot directory exists: {os.path.abspath(screenshot_dir)}")
        os.makedirs(screenshot_dir, exist_ok=True)
    
    abs_path = os.path.abspath(filename)
    logger.info(f"Will save screenshot to: {abs_path}")
    
    # Get window bounds using AppleScript
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    bounds_script = f'''
    tell application "System Events"
        tell process "{app_name}"
            try
                set allWindows to every window
                if length of allWindows is 0 then
                    error "No windows found"
                end if
                
                repeat with w in allWindows
                    set winName to name of w
                    log "Checking window: " & winName
                    if winName contains "â€”" or winName contains "-" then
                        set pos to position of w
                        set sz to size of w
                        return {{(item 1 of pos), (item 2 of pos), (item 1 of sz), (item 2 of sz)}}
                    end if
                end repeat
                error "No suitable window found (no project window found)"
            on error errMsg
                return "error: " & errMsg
            end try
        end tell
    end tell
    '''
    
    bounds_result = subprocess.run(["osascript", "-e", bounds_script], capture_output=True, text=True)
    if bounds_result.returncode == 0 and not bounds_result.stdout.strip().startswith("error:"):
        try:
            # Parse the bounds - format is "x, y, width, height"
            bounds = bounds_result.stdout.strip()
            logger.debug(f"Window bounds: {bounds}")
            
            # Split by comma and clean up the values
            parts = [int(p.strip().strip('{}')) for p in bounds.split(',')]
            if len(parts) != 4:
                raise ValueError(f"Expected 4 values for bounds, got {len(parts)}: {parts}")
                
            x, y, width, height = parts
            if width <= 0 or height <= 0:
                raise ValueError(f"Invalid window dimensions: {width}x{height}")
            
            # Capture the specific region
            capture_cmd = ["screencapture", "-R", f"{x},{y},{width},{height}", filename]
            logger.debug(f"Running capture command: {' '.join(capture_cmd)}")
            
            result = subprocess.run(capture_cmd, capture_output=True, text=True)
            if result.returncode == 0:
                if os.path.exists(filename):
                    logger.info(f"Screenshot saved successfully: {abs_path}")
                    logger.debug(f"File size: {os.path.getsize(filename)} bytes")
                    return filename
                else:
                    logger.warning(f"Warning: screencapture returned success but file not found at {abs_path}")
            else:
                logger.error(f"Failed to capture screenshot. Return code: {result.returncode}")
                if result.stderr:
                    logger.error(f"Error output: {result.stderr}")
        except Exception as e:
            logger.error(f"Error parsing window bounds: {e}")
            logger.error(f"Raw bounds output: {bounds}")
    else:
        logger.error("Could not get Cursor window bounds")
        if bounds_result.stderr:
            logger.error(f"Error output: {bounds_result.stderr}")
    
    return None
</file>

<file path="docs/INSTALLATION.md">
# Installation & Environment

## Python Version Management (Recommended)

To ensure consistent Python version across different machines, use Pyenv:

1. **Install Pyenv:**
   ```bash
   brew install pyenv
   ```
2. **Add Pyenv to your shell configuration:**
   ```bash
   echo 'export PYENV_ROOT="$HOME/.pyenv"' >> ~/.zshrc
   echo 'command -v pyenv >/dev/null || export PATH="$PYENV_ROOT/bin:$PATH"' >> ~/.zshrc
   echo 'eval "$(pyenv init -)"' >> ~/.zshrc
   ```
3. **Install Python 3.13.2:**
   ```bash
   pyenv install 3.13.2
   ```
4. **Set the local Python version:**
   ```bash
   pyenv local 3.13.2
   ```

## Virtual Environment

Create and activate a virtual environment:
```bash
python -m venv venv
source venv/bin/activate
```

## Install Dependencies

Install required packages:
```bash
pip install flask
```

---

Return to [SETUP.md](./SETUP.md) for the main workflow.
</file>

<file path="docs/SETUP.md">
# Setup Guide

## TL;DR

1. **Edit your configuration:**
   - Open `config.json` in the project root and adjust it to fit your project/environment.
2. **Run the main script:**
   - Execute `./run.sh` to start everything. This will:
     - Open your project in Cursor
     - Generate `initial_prompt.txt` from your config
     - Ensure the chat window is open
     - Start both the Slack bot and watcher with unified logs

That's it! For most users, these are the only steps needed.

---

## Full Setup Instructions

For detailed setup with Python version management, virtual environments, and dependency installation, see [INSTALLATION.md](./INSTALLATION.md).
</file>

<file path="run_both.py">
#!/usr/bin/env python3.13
import subprocess
import threading
import sys
import os
import logging
from utils.colored_logging import setup_colored_logging

# Configure logging
setup_colored_logging(debug=os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true")
logger = logging.getLogger('run_both')

def stream_output(process, prefix):
    """Stream output from a process with a prefix"""
    for line in iter(process.stdout.readline, b''):
        # Decode the line and remove any trailing newlines
        line_text = line.decode().rstrip()
        if line_text:  # Only log non-empty lines
            logger.info(f"{prefix} | {line_text}")

def run_flask():
    """Run the Flask server"""
    env = os.environ.copy()
    env["FLASK_APP"] = "slack_bot.py"
    process = subprocess.Popen(
        ["flask", "run", "--port=5005"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        env=env,
        text=False
    )
    stream_output(process, "FLASK")

def run_watcher():
    """Run the watcher process"""
    process = subprocess.Popen(
        ["python3", "watcher.py"],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=False
    )
    stream_output(process, "WATCH")

if __name__ == "__main__":
    logger.info("Starting both processes...")
    
    # Start each process in its own thread
    flask_thread = threading.Thread(target=run_flask)
    watcher_thread = threading.Thread(target=run_watcher)
    
    flask_thread.daemon = True
    watcher_thread.daemon = True
    
    flask_thread.start()
    watcher_thread.start()
    
    # Keep the main thread alive
    try:
        while True:
            flask_thread.join(1)
            watcher_thread.join(1)
    except KeyboardInterrupt:
        logger.info("Shutting down...")
        sys.exit(0)
</file>

<file path="slack_bot.py">
#!/usr/bin/env python3.13
from flask import Flask, request
from state import set_mode, get_mode
from actions.send_to_cursor import send_prompt
from actions.screenshot import capture_chat_screenshot

app = Flask(__name__)

@app.route("/cursor", methods=["POST"])
def slack_command():
    text = request.form.get("text", "")
    user = request.form.get("user_name", "someone")

    if text.strip() == "code":
        set_mode("code")
        return f"Mode set to CODE â€” you're now in control, {user}!"

    elif text.strip() == "auto":
        set_mode("auto")
        return "Mode set to AUTO â€” Cursor will continue on its own."

    elif text.strip().startswith("send "):
        prompt = text.replace("send ", "", 1)
        send_prompt(prompt)
        return f"Sent to Cursor: {prompt}"

    elif text.strip() == "screenshot":
        file = capture_chat_screenshot()
        return f"Screenshot saved: {file}"

    elif text.strip() == "status":
        return f"Mode: {get_mode()}"

    return "Unknown command."
</file>

<file path="state.py">
import os

STATE_FILE = ".cursor_mode"

# Set initial mode from environment if state file does not exist
def get_mode():
    if not os.path.exists(STATE_FILE):
        auto_env = os.environ.get("CURSOR_AUTOPILOT_AUTO_MODE", "0")
        return "auto" if auto_env == "1" else "code"
    return open(STATE_FILE).read().strip()

def set_mode(mode):
    with open(STATE_FILE, "w") as f:
        f.write(mode)
</file>

<file path=".gitignore">
__pycache__/
venv/
initial_prompt.txt
cursor_window.png
</file>

<file path="docs/AUTOMATION.md">
# Automation & AppleScript

## AppleScript Integration

The project uses AppleScript (osascript) to control Cursor, ensuring the chat window is always activated before sending prompts. This enables seamless automation for:
- Opening the chat window
- Sending code and messages
- Switching between manual and autonomous modes

## File Overview

- `run.sh` â€” Main entry script
- `run_both.py` â€” Runs Slack bot and watcher concurrently with unified logs
- `slack_bot.py` â€” Flask app for Slack bot
- `watcher.py` â€” Watches for inactivity in the project directory and updates based on `task_file_path`.
- `actions/send_to_cursor.py` â€” Handles AppleScript automation for Cursor

## Usage Notes

- All automation (AppleScript, window management, etc.) requires macOS and will not work on Windows.
- You can run as many VMs as your hardware allows, each with its own Cursor Autopilot instance and configuration.

See [SETUP.md](./SETUP.md) for the main workflow.
</file>

<file path="docs/SLACK_BOT.md">
# Slack Bot Usage

The Slack bot listens for commands and enables remote control of Cursor Autopilot via your Slack workspace. Slack bot is NOT IMPLEMENTED YET. API is available

## Supported Commands

- `code` â€” Switch to code mode (manual control)
- `auto` â€” Switch to auto mode (autonomous operation)
- `send <your prompt>` â€” Send a prompt to Cursor
- `screenshot` â€” Capture a chat screenshot
- `status` â€” Get current mode

## Testing Locally

You can test the Slack bot's endpoints directly by sending POST requests to the running Flask server. Use the following `curl` commands to simulate Slack commands:

Replace `USER_NAME` with your desired username (optional).

### Enter Manual Mode (code)
```bash
curl -X POST http://localhost:5005/cursor -d 'text=code&user_name=USER_NAME'
```

### Enable Autonomous Coding (auto)
```bash
curl -X POST http://localhost:5005/cursor -d 'text=auto&user_name=USER_NAME'
```

### Send a Message to Cursor
```bash
curl -X POST http://localhost:5005/cursor -d 'text=send <your message here>&user_name=USER_NAME'
```

### Capture Chat Window Screenshot
```bash
curl -X POST http://localhost:5005/cursor -d 'text=screenshot&user_name=USER_NAME'
```

### Show Current Mode
```bash
curl -X POST http://localhost:5005/cursor -d 'text=status&user_name=USER_NAME'
```

These commands simulate the Slack slash commands as if used in Slack.
</file>

<file path="docs/CONFIGURATION.md">
# Configuration Guide

All major settings are controlled via `config.json` in the project root.

## Example `config.json`

```json
{
  "project_path": "/path/to/your/project",
  "task_file_path": "tasks.md",
  "additional_context_path": "file_structure_analysis/*.md",
  "initial_delay": 10,
  "send_message": true,
  "platform": "cursor",
  "use_vision_api": false
}
```

## Configuration Options

| Option                  | Type    | Description                                                                                 |
|-------------------------|---------|---------------------------------------------------------------------------------------------|
| `project_path`          | string  | Path to the project directory to watch and open with the editor.                            |
| `task_file_path`        | string  | Path to the file that contains your feature/task list for tracking completion.              |
| `additional_context_path` | string | Glob path to important documentation files to provide to the LLM for additional context.     |
| `initial_delay`         | number  | Initial delay (in seconds) before starting automation (default: 10).                        |
| `send_message`          | boolean | Whether to send the initial prompt automatically after launching (default: true).            |
| `platform`              | string  | Editor automation target. Use `cursor` (default) or `windsurf`.                             |
| `use_vision_api`        | boolean | Whether to use the Vision API for chat window detection (default: false).                   |

See [SETUP.md](./SETUP.md) for how to use these options in practice.
</file>

<file path="ensure_chat_window.py">
import time
import os
import json
from actions.send_to_cursor import get_cursor_window_id, take_cursor_screenshot, send_keys, kill_cursor, launch_platform
from actions.openai_vision import is_chat_window_open
import subprocess
import logging
from utils.colored_logging import setup_colored_logging

def get_config():
    config_path = os.path.join(os.path.dirname(__file__), "config.json")
    try:
        with open(config_path, "r") as f:
            return json.load(f)
    except Exception as e:
        logger.warning(f"Could not read config: {e}")
        return {}

# Configure logging
setup_colored_logging(debug=os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true")
logger = logging.getLogger('ensure_chat_window')

def ensure_chat_window(platform=None):
    """
    Ensures the Cursor/Windsurf chat window is open by:
    1. Killing any existing Cursor/Windsurf process
    2. Launching Cursor/Windsurf and waiting for it to be ready
    3. Taking a screenshot and using OpenAI Vision to check if chat window is open (if enabled)
    """
    config = get_config()
    use_vision_api = config.get("use_vision_api", False)
    
    # Use platform from config if not explicitly provided
    if platform is None:
        platform = config.get("platform", "cursor")
    
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    logger.info(f"Using configured IDE: {app_name}")
    logger.info(f"Starting {app_name} chat window check...")
    
    # First kill any existing process
    kill_cursor(platform)
    
    # Launch app and wait for it to be ready
    launch_platform(platform)
    
    if use_vision_api:
        # Take screenshot of window
        logger.info(f"Taking screenshot of {app_name} window...")
        screenshot_path = take_cursor_screenshot(platform=platform)
        if not screenshot_path:
            logger.info(f"Could not take screenshot. Skipping vision check.")
            return
        
        # Check if chat window is open using Vision API
        logger.info("[ensure_chat_window] Sending screenshot to OpenAI Vision...")
        chat_window_open = is_chat_window_open(screenshot_path)
        logger.info(f"[ensure_chat_window] OpenAI Vision detected chat window state: {chat_window_open}")
        
        # If chat window is open, we want to close it
        # If chat window is closed, we want to open it
        # In either case, one Command+L will do the job
        logger.info(f"[ensure_chat_window] Chat window is {'open' if chat_window_open else 'closed'}, sending Command+L to toggle state...")
        send_keys(["command down", "l", "command up"], platform=platform)
    else:
        logger.info("[ensure_chat_window] Vision API disabled, skipping chat window check.")
    
    logger.info("[ensure_chat_window] Done.")

if __name__ == "__main__":
    import sys
    platform = sys.argv[1] if len(sys.argv) > 1 else None
    ensure_chat_window(platform)
</file>

<file path="generate_initial_prompt.py">
import os
import json
import logging
from utils.colored_logging import setup_colored_logging

# Configure logging
setup_colored_logging(debug=os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true")
logger = logging.getLogger('generate_initial_prompt')

# Constants
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")
INITIAL_PROMPT_PATH = os.path.join(os.path.dirname(__file__), "initial_prompt.txt")
INITIAL_PROMPT_SENT_PATH = os.path.join(os.path.dirname(__file__), ".initial_prompt_sent")

# Initial prompt for new chats
INITIAL_PROMPT = """I am working on a coding task. Please help me complete it. I will share the task details and any relevant context."""

# Continuation prompt for existing chats
CONTINUATION_PROMPT = """I have made some changes to the code. Please review them and help me continue working on the task."""

def get_config():
    """Get the configuration from config.json."""
    try:
        with open(CONFIG_PATH, "r") as f:
            return json.load(f)
    except Exception as e:
        logger.error(f"Config file not found at {CONFIG_PATH}")
        return {}

def generate_prompt():
    """Generate the appropriate prompt based on whether initial prompt was sent."""
    config = get_config()
    
    # Check if initial prompt was sent
    is_new_chat = not os.path.exists(INITIAL_PROMPT_SENT_PATH)
    
    if is_new_chat:
        logger.info("Initial prompt has not been sent yet, using INITIAL_PROMPT")
        prompt = INITIAL_PROMPT
    else:
        logger.info("Initial prompt was already sent, using CONTINUATION_PROMPT")
        prompt = CONTINUATION_PROMPT
    
    # Write prompt to file
    with open(INITIAL_PROMPT_PATH, "w") as f:
        f.write(prompt)
    
    logger.info(f"Wrote {'initial' if is_new_chat else 'continuation'} prompt to {INITIAL_PROMPT_PATH}")
    
    # Create marker file if this is a new chat
    if is_new_chat:
        with open(INITIAL_PROMPT_SENT_PATH, "w") as f:
            f.write("")
        logger.info("Created .initial_prompt_sent marker file")
    
    return prompt

if __name__ == "__main__":
    generate_prompt()
</file>

<file path="README.md">
# Cursor Autopilot

## TL;DR

1. **Edit your configuration:**
   - Open `config.json` and adjust it for your project (be sure to use `task_file_path` for your task/feature file).
2. **Run the main script:**
   - Execute `./run.sh` to start everything.

Thatâ€™s it! For most users, these are the only steps needed.

---

## ðŸ“š Documentation

- [Setup Guide](./docs/SETUP.md)
- [Configuration Options](./docs/CONFIGURATION.md)
- [Installation & Environment](./docs/INSTALLATION.md)
- [Slack Bot Usage](./docs/SLACK_BOT.md)
- [Automation & AppleScript](./docs/AUTOMATION.md)
</file>

<file path="config.json">
{
  "project_path": "/Users/cheddarwhizzy/cheddar/payload-website",
  "task_file_path": "tasks.md",
  "additional_context_path": "context.md",
  "initial_delay": 10,
  "send_message": true,
  "platform": "windsurf",
  "use_vision_api": false,
  "debug": true,
  "inactivity_delay": 120
}
</file>

<file path="run.sh">
#!/bin/bash

# Check if pyenv is installed
if ! command -v pyenv >/dev/null 2>&1; then
    echo "pyenv is required but not found."
    echo "Would you like to install it now with 'brew install pyenv'?"
    read -p "Press [Enter] to install or Ctrl+C to cancel..."
    if command -v brew >/dev/null 2>&1; then
        brew install pyenv
        if ! command -v pyenv >/dev/null 2>&1; then
            echo "pyenv installation failed. Please install it manually and re-run this script."
            exit 1
        fi
    else
        echo "Homebrew is not installed. Please install Homebrew first: https://brew.sh/"
        exit 1
    fi
fi

# Set Python version using pyenv
echo "Setting Python version to 3.13.2..."
pyenv local 3.13.2

# Create and activate virtual environment if it doesn't exist
if [ ! -d "venv" ]; then
    echo "Creating virtual environment..."
    python -m venv venv
fi

# Activate virtual environment
echo "Activating virtual environment..."
source venv/bin/activate

# Verify Python version
PYTHON_VERSION=$(python --version 2>&1 | awk '{print $2}')
if [[ ! "$PYTHON_VERSION" =~ ^3\.13\. ]]; then
    echo "Error: Virtual environment is not using Python 3.13+ (current version: $PYTHON_VERSION)"
    echo "Please delete the venv directory and run this script again"
    exit 1
fi

# Install required packages
echo "Installing required Python packages..."
pip install -r requirements.txt 2>&1 > /dev/null

# Check for tesseract-ocr (needed for pytesseract)
if ! command -v tesseract >/dev/null 2>&1; then
  echo "Warning: tesseract-ocr is not installed. Please install it with 'brew install tesseract' for OCR support."
fi

# === CONFIGURATION ===
# Extract PROJECT_PATH and PLATFORM from config.json
export CONFIG_FILE="$(dirname "$0")/config.json"
if [ -f "$CONFIG_FILE" ]; then
  CONFIG_VALUES=$(python3 -c 'import json,os; c=json.load(open(os.environ["CONFIG_FILE"])); print(os.path.expanduser(c["project_path"]) + "\t" + c["platform"])' CONFIG_FILE="$CONFIG_FILE")
  PROJECT_PATH=$(echo "$CONFIG_VALUES" | cut -f1)
  PLATFORM=$(echo "$CONFIG_VALUES" | cut -f2)
else
  echo "Error: config.json not found. Set CONFIG_FILE environment variable to the path of your config.json file."
  exit 1
fi

# The initial prompt is now stored in initial_prompt.txt

# Parse flags for auto mode and send message behavior
auto_mode=0
send_message=true
debug_mode=false

for arg in "$@"; do
  case $arg in
    --auto)
      auto_mode=1
      ;;
    --no-auto)
      auto_mode=0
      ;;
    --no-send)
      send_message=false
      ;;
    --send)
      send_message=true
      ;;
    --debug)
      debug_mode=true
      ;;
  esac
done

export CURSOR_AUTOPILOT_AUTO_MODE=$auto_mode
export CURSOR_AUTOPILOT_DEBUG=$debug_mode

# Update send_message in config.json
python3 -c '
import json
import os
config_file = os.environ["CONFIG_FILE"]
with open(config_file, "r") as f:
    config = json.load(f)
config["send_message"] = True if "'$send_message'" == "true" else False
config["debug"] = True if "'$debug_mode'" == "true" else False
config["inactivity_delay"] = config.get("inactivity_delay", 120)  # Default to 120 seconds if not set
with open(config_file, "w") as f:
    json.dump(config, f, indent=2)
'

# === STEP 1: KILL EXISTING APPLICATION IF RUNNING ===
if [ "$PLATFORM" = "windsurf" ]; then
  pkill -f "Windsurf" || true
  APP_NAME="Windsurf"
else
  pkill -f "Cursor" || true
  APP_NAME="Cursor"
fi

# === STEP 2: OPEN FOLDER IN APPROPRIATE APPLICATION ===
open -a "$APP_NAME" "$PROJECT_PATH"

python3 generate_initial_prompt.py

# Ensure chat window is open using OpenAI Vision
python3 ensure_chat_window.py "$PLATFORM"

# Send the initial prompt immediately after opening the chat window, starting a new chat
if [ -f "initial_prompt.txt" ]; then
  python3 -c 'import json,os; from actions.send_to_cursor import send_prompt; config=json.load(open(os.environ["CONFIG_FILE"])); send_prompt(open("initial_prompt.txt").read().strip(), platform=config.get("platform", "cursor"), new_chat=True, send_message=config.get("send_message", True))'
fi

# Start Slack bot and watcher together with combined logs
echo "Starting Slack bot and Cursor watcher... (auto mode: $auto_mode, send messages: $send_message)"
python3 run_both.py $auto_mode "$PLATFORM"
</file>

<file path="actions/send_to_cursor.py">
import subprocess
import os
import time
from actions.openai_vision import is_chat_window_open
import json
import logging
from utils.colored_logging import setup_colored_logging

# Configure logging
setup_colored_logging(debug=os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true")
logger = logging.getLogger('send_to_cursor')

# Add debug info about logging level
logger.debug("Debug logging enabled") if os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true" else logger.info("Info logging enabled")

def get_project_name():
    """Get the project name from the config file."""
    config_path = os.path.join(os.path.dirname(os.path.dirname(__file__)), "config.json")
    try:
        with open(config_path) as f:
            config = json.load(f)
            # Get the last part of the project path
            return os.path.basename(config["project_path"])
    except Exception as e:
        logger.warning(f"Could not get project name from config: {e}")
        return None

def get_cursor_window_id(max_retries=5, delay=1, platform="cursor"):
    """
    Gets the window ID of the Cursor/Windsurf app using AppleScript.
    Retries several times if not found, with debug info.
    Returns the window ID as a string, or None if not found.
    """
    project_name = get_project_name()
    if not project_name:
        logger.info("No project name found in config, will try to find any window")
    
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    
    # List all windows and their properties
    windows_script = f'''
    tell application "System Events"
        tell process "{app_name}"
            set windowList to {{}}
            repeat with w in every window
                copy {{title:name of w, id:id of w, position:position of w, size:size of w}} to end of windowList
            end repeat
            return windowList
        end tell
    end tell
    '''
    
    for attempt in range(max_retries):
        logger.info(f"Attempt {attempt+1} to find {app_name} window...")
        result = subprocess.run(["osascript", "-e", windows_script], capture_output=True, text=True)
        
        if result.returncode == 0 and result.stdout.strip():
            logger.info(f"Found windows: {result.stdout.strip()}")
            
            # Try to find the project window
            window_check = 'true' if not project_name else f'name of w contains "â€” {project_name}" or name of w contains "- {project_name}"'
            find_window_script = f'''
            tell application "System Events"
                tell process "{app_name}"
                    repeat with w in every window
                        if {window_check} then
                            return id of w
                        end if
                    end repeat
                end tell
            end tell
            '''
            
            window_result = subprocess.run(["osascript", "-e", find_window_script], capture_output=True, text=True)
            if window_result.returncode == 0 and window_result.stdout.strip():
                window_id = window_result.stdout.strip()
                logger.info(f"Found main window ID: {window_id}")
                return window_id
        
        logger.info(f"Attempt {attempt+1} failed.")
        if result.stderr:
            logger.warning(f"Error output: {result.stderr.strip()}")
        time.sleep(delay)
    
    logger.warning("Could not find window ID after retries.")
    return None

def activate_platform(platform="cursor"):
    """Activate the Cursor or Windsurf application window."""
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    logger.info(f"Activating {app_name}...")
    script = f'''
    tell application "{app_name}" to activate
    delay 1
    tell application "System Events"
        tell process "{app_name}"
            set frontmost to true
        end tell
    end tell
    delay 1
    '''
    subprocess.run(["osascript", "-e", script])
    # Add extra delay after activation to ensure app is fully ready
    logger.info(f"Waiting 3 seconds for {app_name} to fully initialize...")
    time.sleep(3)
    logger.info("Done.")

def take_cursor_screenshot(filename="cursor_window.png", platform="cursor"):
    """
    Takes a screenshot of the Cursor/Windsurf window and saves it as filename.
    Returns the path to the screenshot, or None if failed.
    """
    project_name = get_project_name()
    if not project_name:
        logger.warning("No project name found in config, will try to find any window")
    
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    abs_path = os.path.abspath(filename)
    logger.info(f"Attempting to take screenshot, will save to: {abs_path}")
    
    # First list all processes to debug
    process_script = '''
    tell application "System Events"
        set allProcesses to name of every process
        return allProcesses
    end tell
    '''
    
    process_result = subprocess.run(["osascript", "-e", process_script], capture_output=True, text=True)
    if process_result.returncode == 0:
        logger.debug(f"All processes: {process_result.stdout.strip()}")
    
    # First list all windows to debug
    debug_script = f'''
    tell application "System Events"
        tell process "{app_name}"
            set windowInfo to ""
            repeat with w in every window
                set windowInfo to windowInfo & "Window: " & name of w & ", "
            end repeat
            return windowInfo
        end tell
    end tell
    '''
    
    debug_result = subprocess.run(["osascript", "-e", debug_script], capture_output=True, text=True)
    if debug_result.returncode == 0:
        logger.debug(f"Found {app_name} windows: {debug_result.stdout.strip()}")
    else:
        logger.warning("Could not list windows")
        if debug_result.stderr:
            logger.warning(f"Debug error: {debug_result.stderr}")
    
    # Get window bounds using AppleScript
    window_check = 'true' if not project_name else f'winName contains "â€” {project_name}" or winName contains "- {project_name}"'
    bounds_script = f'''
    tell application "System Events"
        tell process "{app_name}"
            try
                set allWindows to every window
                if length of allWindows is 0 then
                    error "No windows found"
                end if
                
                repeat with w in allWindows
                    set winName to name of w
                    log "Checking window: " & winName
                    if {window_check} then
                        set pos to position of w
                        set sz to size of w
                        return {{(item 1 of pos), (item 2 of pos), (item 1 of sz), (item 2 of sz)}}
                    end if
                end repeat
                error "No suitable window found (no project window found)"
            on error errMsg
                return "error: " & errMsg
            end try
        end tell
    end tell
    '''
    
    bounds_result = subprocess.run(["osascript", "-e", bounds_script], capture_output=True, text=True)
    if bounds_result.returncode == 0 and not bounds_result.stdout.strip().startswith("error:"):
        try:
            # Parse the bounds - format is "x, y, width, height"
            bounds = bounds_result.stdout.strip()
            logger.debug(f"Window bounds: {bounds}")
            
            # Split by comma and clean up the values
            parts = [int(p.strip().strip('{}')) for p in bounds.split(',')]
            if len(parts) != 4:
                raise ValueError(f"Expected 4 values for bounds, got {len(parts)}: {parts}")
                
            x, y, width, height = parts
            if width <= 0 or height <= 0:
                raise ValueError(f"Invalid window dimensions: {width}x{height}")
            
            # Capture the specific region
            capture_cmd = ["screencapture", "-R", f"{x},{y},{width},{height}", filename]
            logger.debug(f"Running capture command: {' '.join(capture_cmd)}")
            
            result = subprocess.run(capture_cmd, capture_output=True, text=True)
            if result.returncode == 0:
                if os.path.exists(filename):
                    logger.info(f"Screenshot saved successfully: {filename}")
                    logger.debug(f"File size: {os.path.getsize(filename)} bytes")
                    return filename
                else:
                    logger.warning(f"Warning: screencapture returned success but file not found at {abs_path}")
            else:
                logger.error(f"Failed to capture screenshot. Return code: {result.returncode}")
                if result.stderr:
                    logger.error(f"Error output: {result.stderr}")
        except Exception as e:
            logger.error(f"Error parsing window bounds: {e}")
            logger.error(f"Raw bounds output: {bounds}")
    else:
        error_msg = bounds_result.stdout.strip()[7:] if bounds_result.stdout.strip().startswith("error:") else "unknown error"
        logger.error(f"Could not get window bounds: {error_msg}")
        if bounds_result.stderr:
            logger.error(f"Error output: {bounds_result.stderr}")
    
    return None

def send_keys(key_sequence, platform="cursor"):
    """
    Send a sequence of keystrokes to Cursor/Windsurf.
    key_sequence should be a list of strings, e.g. ["command down", "l", "command up"]
    """
    logger.info(f"Sending key sequence: {key_sequence}")
    
    # First make sure Cursor/Windsurf is properly activated
    activate_script = f'''
    tell application "{'Windsurf' if platform == 'windsurf' else 'Cursor'}" to activate
    delay 1
    tell application "System Events"
        tell process "{'Windsurf' if platform == 'windsurf' else 'Cursor'}"
            set frontmost to true
        end tell
    end tell
    delay 1
    '''
    
    logger.info("Ensuring app is active...")
    activate_result = subprocess.run(["osascript", "-e", activate_script], capture_output=True, text=True)
    if activate_result.returncode != 0:
        logger.warning(f"Error activating app: {activate_result.stderr}")
    
    # Add a delay to ensure app is ready
    logger.info("Waiting 2 seconds for app to be ready...")
    time.sleep(2)
    
    # Now send the keystroke
    script = f'''
    tell application "System Events"
        tell process "{'Windsurf' if platform == 'windsurf' else 'Cursor'}"
            keystroke "l" using {{command down}}
        end tell
    end tell
    '''
    
    logger.info("Executing keystroke...")
    result = subprocess.run(["osascript", "-e", script], capture_output=True, text=True)
    if result.returncode == 0:
        logger.info("Keys sent successfully")
    else:
        logger.error(f"Error sending keys: {result.stderr}")

def send_prompt(prompt, platform="cursor", new_chat=False, initial_delay=0, send_message=True):
    """
    Send a prompt to the specified platform with verbose logging and delays.
    """
    if initial_delay > 0:
        logger.info(f"Waiting {initial_delay} seconds before sending prompt...")
        time.sleep(initial_delay)
    
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    logger.info(f"Starting to send prompt to {app_name}...")
    
    # Activate the application
    logger.info(f"Activating {app_name}...")
    activate_platform(platform)
    
    if new_chat:
        logger.info(f"Creating new chat window in {app_name}...")
        if platform == "cursor":
            # Send Command+N to create a new chat
            script = f'''
            tell application "System Events"
                tell process "{app_name}"
                    keystroke "n" using {{command down}}
                end tell
            end tell
            '''
            logger.info("Sending Command+N to create new chat...")
            subprocess.run(["osascript", "-e", script])
            logger.info("Waiting 2 seconds for new chat to open...")
            time.sleep(2)
            
            # Open the chat window with Command+L
            logger.info("Sending Command+L to open chat window...")
            script = f'''
            tell application "System Events"
                tell process "{app_name}"
                    keystroke "l" using {{command down}}
                end tell
            end tell
            '''
            subprocess.run(["osascript", "-e", script])
            logger.info("Waiting 2 seconds for chat window to fully open...")
            time.sleep(2)
        else:  # windsurf
            # Send Command+Shift+L to create a new chat
            logger.info("Sending Command+Shift+L to create new chat...")
            script = f'''
            tell application "System Events"
                tell process "{app_name}"
                    keystroke "l" using {{command down, shift down}}
                end tell
            end tell
            '''
            subprocess.run(["osascript", "-e", script])
            logger.info("Waiting 2 seconds for new chat to open...")
            time.sleep(2)
    
    # Clear any existing text with Command+A then backspace
    logger.info("Clearing any existing text...")
    script = f'''
    tell application "System Events"
        tell process "{app_name}"
            -- Select all text
            keystroke "a" using {{command down}}
            delay 0.1
            
            -- Press delete key multiple times to ensure text is cleared
            repeat 10 times
                key code 51  -- Delete/Backspace key
                delay 0.05
            end repeat
        end tell
    end tell
    '''
    subprocess.run(["osascript", "-e", script])
    logger.info("Waiting 1 second after clearing text...")
    time.sleep(1)
    
    # Split prompt into lines and send with Shift+Enter between them
    lines = prompt.splitlines()
    logger.info(f"Sending {len(lines)} lines of text...")
    
    for i, line in enumerate(lines):
        # Send the line
        logger.info(f"Sending line {i+1}/{len(lines)}: {line[:50]}{'...' if len(line) > 50 else ''}")
        script = f'''
        tell application "System Events"
            tell process "{app_name}"
                keystroke "{line.replace('"', '\\"')}"
            end tell
        end tell
        '''
        subprocess.run(["osascript", "-e", script])
        
        if i < len(lines) - 1:
            logger.info("Sending Shift+Enter for newline...")
            script = f'''
            tell application "System Events"
                tell process "{app_name}"
                    key code 36 using {{shift down}}  -- Shift+Enter
                end tell
            end tell
            '''
            subprocess.run(["osascript", "-e", script])
            logger.info("Waiting 0.8 seconds after newline...")
            time.sleep(0.8)
        elif send_message:
            logger.info("Sending Enter to send message...")
            script = f'''
            tell application "System Events"
                tell process "{app_name}"
                    key code 36  -- Enter
                end tell
            end tell
            '''
            subprocess.run(["osascript", "-e", script])
            logger.info("Waiting 1 second after sending message...")
            time.sleep(1)
    
    logger.info("Prompt sent successfully!")

def kill_cursor(platform="cursor"):
    """Kill the Cursor or Windsurf application if it's running."""
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    logger.info(f"Checking if {app_name} is running...")
    
    # Check if app is running
    check_script = f'''
    tell application "System Events"
        count (every process whose name is "{app_name}")
    end tell
    '''
    
    result = subprocess.run(["osascript", "-e", check_script], capture_output=True, text=True)
    if result.returncode == 0 and result.stdout.strip() != "0":
        logger.info(f"{app_name} is running, killing it...")
        subprocess.run(["pkill", "-x", app_name])
        logger.info(f"Waiting 2 seconds for process to fully terminate...")
        time.sleep(2)  # Wait longer for process to fully terminate
        logger.info("Done.")
    else:
        logger.info(f"{app_name} is not running.")

def launch_platform(platform="cursor"):
    """Launch Cursor or Windsurf and wait for it to be ready."""
    app_name = "Windsurf" if platform == "windsurf" else "Cursor"
    logger.info(f"Starting {app_name}...")
    subprocess.run(["open", "-a", app_name])
    
    # Wait for process to appear
    logger.info(f"Waiting for {app_name} process...")
    for _ in range(10):  # Try for 10 seconds
        check_script = f'''
        tell application "System Events"
            count (every process whose name is "{app_name}")
        end tell
        '''
        result = subprocess.run(["osascript", "-e", check_script], capture_output=True, text=True)
        if result.returncode == 0 and result.stdout.strip() != "0":
            logger.info(f"{app_name} process detected.")
            break
        time.sleep(1)
    
    # For Windsurf, press Enter to clear any dialog boxes
    if platform == "windsurf":
        logger.info("Pressing Enter to clear any dialog boxes in Windsurf...")
        script = '''
        tell application "System Events"
            tell process "Windsurf"
                key code 36  -- Enter key
            end tell
        end tell
        '''
        subprocess.run(["osascript", "-e", script])
        logger.info("Waiting 1 second after pressing Enter...")
        time.sleep(1)
    
    # Give it extra time to fully initialize
    logger.info(f"Waiting 5 seconds for {app_name} to fully initialize...")
    time.sleep(5)
    
    logger.info("Done.")
</file>

<file path="watcher.py">
#!/usr/bin/env python3.13
import time
import os
import hashlib
import json
from datetime import datetime
from actions.send_to_cursor import send_prompt
from state import get_mode
from generate_initial_prompt import CONTINUATION_PROMPT
import logging
from utils.colored_logging import setup_colored_logging

# Configure logging
setup_colored_logging(debug=os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true")
logger = logging.getLogger('watcher')

# Add debug info about logging level
logger.debug("Debug logging enabled") if os.environ.get("CURSOR_AUTOPILOT_DEBUG") == "true" else logger.info("Info logging enabled")

EXCLUDE_DIRS = {"node_modules", ".git", "dist", "__pycache__"}
LAST_HASH = None
FILE_MTIMES = {}

# --- Configurable README tracking ---
CONFIG_PATH = os.path.join(os.path.dirname(__file__), "config.json")
if os.path.exists(CONFIG_PATH):
    with open(CONFIG_PATH, "r") as f:
        config = json.load(f)
else:
    config = {}

# Get paths from config
WATCH_PATH = os.path.expanduser(config.get("project_path", "~/cheddar/mushattention/mushattention"))
TASK_FILE_PATH = config.get("task_file_path", "tasks.md")
LAST_README_MTIME = None
TASK_COMPLETED = False
PLATFORM = config.get("platform", "cursor")
INACTIVITY_DELAY = config.get("inactivity_delay", 120)  # Default to 120 seconds if not specified

# Add debug info about paths
logger.info(f"Watcher Configuration:")
logger.info(f"Project Path: {WATCH_PATH}")
logger.info(f"Task README: {TASK_FILE_PATH}")
logger.info(f"Platform: {PLATFORM}")
logger.info(f"Inactivity Delay: {INACTIVITY_DELAY} seconds")
logger.info(f"Excluded Dirs: {EXCLUDE_DIRS}")

def hash_folder_state():
    """
    Scan directory for changes and return:
    - A hash representing the current state
    - List of files that changed since last scan
    - Total number of files being watched
    """
    sha = hashlib.sha256()
    changed_files = []
    total_files = 0
    
    # Walk through directory
    for root, dirs, files in os.walk(WATCH_PATH):
        # Filter out excluded directories
        dirs[:] = [d for d in dirs if d not in EXCLUDE_DIRS]
        
        # Process each file
        for filename in sorted(files):  # Sort for consistent ordering
            if filename.endswith(".tmp"): 
                continue
                
            abs_path = os.path.join(root, filename)
            rel_path = os.path.relpath(abs_path, WATCH_PATH)
            
            try:
                # Get file stats
                stats = os.stat(abs_path)
                current_mtime = stats.st_mtime
                current_size = stats.st_size
                
                # Create a unique hash for this file's state
                file_state = f"{rel_path}:{current_mtime}:{current_size}"
                sha.update(file_state.encode())
                
                # Check if file changed
                last_mtime = FILE_MTIMES.get(abs_path, {}).get('mtime')
                last_size = FILE_MTIMES.get(abs_path, {}).get('size')
                
                if last_mtime is None or last_size is None or \
                   current_mtime > last_mtime or current_size != last_size:
                    changed_files.append(rel_path)
                    FILE_MTIMES[abs_path] = {
                        'mtime': current_mtime,
                        'size': current_size
                    }
                    logger.info(f"File changed: {rel_path}")
                    logger.info(f"  Last modified: {datetime.fromtimestamp(current_mtime)}")
                    logger.info(f"  Size: {current_size} bytes")
                
                total_files += 1
                
            except OSError as e:
                logger.warning(f"Could not access {rel_path}: {e}")
                continue
    
    return sha.hexdigest(), changed_files, total_files

def run_watcher():
    """
    Main watcher loop that monitors for changes and sends prompts.
    """
    global LAST_HASH, FILE_MTIMES, LAST_README_MTIME
    
    inactivity_timer = 0
    last_activity = time.time()
    last_prompt_time = 0  # Track when we last sent a prompt
    
    # Check if initial prompt has been sent
    initial_prompt_sent = os.path.exists(os.path.join(os.path.dirname(__file__), ".initial_prompt_sent"))
    logger.info(f"Initial prompt {'has' if initial_prompt_sent else 'has not'} been sent yet")
    
    while True:
        try:
            # Get current state
            current_hash, changed_files, total_files = hash_folder_state()
            
            # Check if task file was modified
            task_file_modified = False
            if TASK_FILE_PATH in changed_files:
                current_mtime = os.path.getmtime(TASK_FILE_PATH)
                if LAST_README_MTIME is None or current_mtime > LAST_README_MTIME:
                    task_file_modified = True
                    LAST_README_MTIME = current_mtime
                    logger.info(f"Task file {TASK_FILE_PATH} was modified!")
                    logger.info(f"  Last modified: {datetime.fromtimestamp(current_mtime)}")
            
            # Update inactivity timer
            if current_hash != LAST_HASH or task_file_modified:
                inactivity_timer = 0
                last_activity = time.time()
                LAST_HASH = current_hash
                logger.info(f"Activity detected! Resetting inactivity timer (was at {int(inactivity_timer)} seconds)")
                if changed_files:
                    logger.info(f"  Changed files: {', '.join(changed_files)}")
            else:
                inactivity_timer = time.time() - last_activity
                if inactivity_timer >= 30:  # Log status when getting close to timeout
                    logger.info(f"No changes detected for {int(inactivity_timer)} seconds")
                    logger.info(f"  Will send prompt in {max(0, INACTIVITY_DELAY-int(inactivity_timer))} seconds if no changes occur")
            
            # Check for inactivity timeout
            if inactivity_timer >= INACTIVITY_DELAY and get_mode() == "auto":
                current_time = time.time()
                # Only send a new prompt if it's been at least INACTIVITY_DELAY seconds since the last one
                if current_time - last_prompt_time >= INACTIVITY_DELAY:
                    logger.info(f"Inactivity timeout reached ({int(inactivity_timer)} seconds). Sending prompt to {PLATFORM}.")
                    
                    # Use the appropriate prompt based on whether initial prompt was sent
                    if not initial_prompt_sent:
                        try:
                            with open("initial_prompt.txt", "r") as f:
                                prompt = f.read().strip()
                        except Exception as e:
                            logger.error(f"Failed to read initial_prompt.txt: {e}")
                            prompt = "continue"
                        logger.info("Starting new chat with initial prompt")
                        send_prompt(prompt, platform=PLATFORM, new_chat=True, 
                                  initial_delay=config.get("initial_delay", 10),
                                  send_message=config.get("send_message", True))
                        initial_prompt_sent = True
                    else:
                        # Use the continuation prompt
                        prompt = CONTINUATION_PROMPT.format(
                            task_file_path=config.get("task_file_path", "tasks.md"),
                            additional_context_path=config.get("additional_context_path", "context.md")
                        )
                        logger.info("Sending continuation prompt")
                        send_prompt(prompt, platform=PLATFORM, new_chat=False,
                                  send_message=config.get("send_message", True))
                    
                    last_prompt_time = current_time
                    inactivity_timer = 0
                    logger.info("Watching for changes...")
                else:
                    logger.info(f"Skipping prompt - last prompt was sent {int(current_time - last_prompt_time)} seconds ago")
            
            time.sleep(5)  # Check every 5 seconds
        except Exception as e:
            logger.error(f"Error in watcher: {e}")
            time.sleep(5)  # Wait before retrying

if __name__ == "__main__":
    run_watcher()
</file>

</files>
